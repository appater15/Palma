# -*- coding: utf-8 -*-
"""
Finance
"""

import numpy as np
from cvxopt import matrix, solvers
import matplotlib.pyplot as plt

n=20
def mu(x) :
    return 2*x

def nu(x) :
    return 1
    
def cout(x,y):
    return (x-y)**2

def integration(f,xmin,xmax):
    s=0.
    nbr=20
    pas=(xmax-xmin)/float(nbr)
    for i in range(nbr):
        s+=f(xmin+pas*i)*pas
    return s

def creerA(n):
    A=[]
    for i in range(n):
        ligne=[0. for k in range(n*n)]
        for j in range(n):
            ligne[i*n+j]=1.
        A.append(ligne)
    for i in range(n-1):
        ligne=[0. for k in range(n*n)]
        for j in range(n):
            ligne[i+j*n]=1.
        A.append(ligne)
    A=np.array(A)
    return A
      
    
def creeraetb(a,b,n):
    d=np.zeros((2*n-1))
    for i in range(n):
        d[i]=a[i]
    for i in range(n-1):
        d[i+n]=b[i]
    return d

def solve(a,b,c,n):    
    A=matrix(creerA(n))
    d=matrix(creeraetb(a,b,n))
    c=matrix(c)
    h=np.zeros((n*n))
    h=matrix(h)
    G=-np.eye((n*n))
    G=matrix(G)
    dims ={'l':G.size[0], 'q':[], 's':[]}
    return solvers.conelp(c,G,h,dims,A,d)
    
def reassemblage(PI,n):
    M=np.zeros((n,n))
    for i in range(n):
        for j in range(n):
            M[i,j]=PI[j+i*n]
    return M

a=np.zeros((n))
b=np.zeros((n))

for i in range(n):
    a[i]=integration(mu,float(i)/n,(float(i)+1)/n)
    b[i]=integration(nu,float(i)/n,(float(i)+1)/n)

c=np.zeros((n*n))

for i in range(n):
    for j in range(n):
        c[j+n*i]=cout((float(i)+1)/n,(float(j)+1)/n)
        

PI=solve(a,b,c,n)['x']
plt.imshow(reassemblage(PI,n))




"""
Finance 2
"""

import numpy as np
from cvxopt import matrix, solvers
import matplotlib.pyplot as plt


n=11
m=21
a=-0.5
b=0.7

    
def cout(x,y):
    if y<x:
        return 0
    return (y-x)


def creerA(n,m):
    A=[]
    for i in range(n):
        ligne=[0. for k in range(n*m)]
        for j in range(m):
            ligne[i*m+j]=1.
        A.append(ligne)
    for j in range(m):
        ligne=[0. for k in range(n*m)]
        for i in range(n):
            ligne[i*m+j]=1.
        A.append(ligne)
    A=np.array(A)
    return A
    
def creerA2(n,m):
    A=[]
    for i in range(n):
        ligne=[0. for k in range(n*m)]
        for j in range(m):
            ligne[i+j*m]=(1+a)**j*(1+b)**(m+1-j)
        A.append(ligne)
    
def creerABS(A1,A2):
    np.concatenate(A1,A2,axis=0)
    
# def aBS(p,m):
#     a=np.zeros(m)
#     for j in range(m):
#         a[j]=scipy.special.binom(j, m-1)*((1-p)**(10-j))*p**j
# 
#     return a
#     
#     
# def bBS(p,n):
#     b=np.zeros(n)
#     for j in range(n):
#         a[j]=scipy.special.binom(j, n)*((1-p)**(10-j))*p**j
#     return b
#     
#       
    


def solve(c,d,n,m):    
    A1=matrix(creerA(n,m))
    A2=creerA2(n,m)
    A=creerABS(A1,A2)
    c=matrix(c)
    d=matrix(d)
    h=np.zeros((n*m))
    h=matrix(h)
    G=-np.eye((n*m))
    G=matrix(G)
    dims ={'l':G.size[0], 'q':[], 's':[]}
    return solvers.conelp(c,G,h,dims,A,d)
    
def reassemblage(PI,n,m):
    M=np.zeros((m,n))
    for i in range(m):
        for j in range(n):
            M[j,i]=PI[i+j*m]
    return M


d=np.zeros((n*m))

for i in range(n):
    d[i]=(math.factorial(n-1) // (math.factorial(i)*(math.factorial(n-1-i))))*((1-p)**(n-1-i))*p**(i)
    
    
for j in range (m):
    d[n+j]=math.factorial(m-1) // (math.factorial(j)*(math.factorial(m-1-j)))*((1-p)**(m-1-j))*p**(j)
    
for i in range(n):
    d[n+m+i]=(math.factorial(n-1) // (math.factorial(i)*(math.factorial(n-1-i))))*(1-p)**(n-1-i)*p**(i)*((1+a)**i)*((1+b)**(n-1-i))
    
c=np.zeros(n*m)
        
for i in range(n):
    for j in range(m):
        c[j+n*i]=cout(((1+a)**i)*(1+b)**(n-1-i),((1+a)**j)*(1+b)**(m-1-j))
        
PI=solve(c,d,n,m)['x']
plt.imshow(reassemblage(PI,n,m))

